This files describes all the optimizations ideas we left out for now.

Things that are not needed if the WASM was optimized in the first place:

- [prune_block_io]: if the same value is given at diferent input slots
  of a block, we can unify them into a single slot and remap the block
  inputs accordingly. This is not trivial to detect in loops, but
  something of the sorts is already implemented, when detecting if some
  input is redirected unchanged to the next iterations.

Unlikely to be useful optimizations:

- [(wom)prune_block_io]: sometimes a loop needs to take inputs just to output
  them in certain breaks, unmodified. Such values would have to be copied
  over through all the iterations, but never actually used inside the loop.
  In such cases, it is worth to make these breaks indirect, by creating
  blocks surrounding the loop just to forward the breaks. The passthrough
  values will be handled by the outside blocks and breaks, avoiding them
  to be copied into the loop (the information wether each input fits this
  criteria should already be available inside prune_block_io).

- [register_allocation]: the register allocation is not perfectly optimal,
  it just uses a greedy approach to assign registers, and give up when it
  detects a conflict. It may be possible to model the problem to a SAT
  solver or something like that.

Likely to be useful optimizations

- [(wom)]: if there are more than one loop nested inside each other, and
  the inner loop falls through the outer loop, which then breaks or falls
  through again, it is better to have the inner loop break directly to the
  final destination instead of going through multiple frame barriers, because
  each frame barrier potentially adds multiple copies.

- [tail call]: a call immediately followed by a return can be optimized
  to a tail call. In WOM we can even do this for calls where its outputs
  are not related to the return values, because we can set the
  return registers before the tail call. Note on RW: it seems the chosen
  calling convention for RW, where the return address and frame pointer
  are stored after the arguments, makes this optimization impossible in
  most cases. We should revise the calling convention eventually.

- [liveness]: calculate the liveness for all possible control flow paths,
  releasing values earlier when possible, which may reduce register
  pressure.

- [(rw)register-allocation]: implement a simple heuristic to try to avoid
  having to copy the function outputs to the slots allocated for them by
  the nodes who uses them as inputs.
  
  The idea goes like this: we first check if an output slot was specifically
  requested by the user node with a hint. If it was, then we most likely
  have to do copy it anyway, so we stop. If it wasn't, we check if between
  this call and the last user of the output there are no other function calls
  (and we must check inside the loop blocks as well). If there are not,
  then we can set the output slots to the ones that naturally
  follow from the function call, avoiding a register copy. In this
  case, it is also possible that we can shift the call frame
  itself some slots up, as the removal of the original output slots
  might have freed up some space.

  The search can follow uncoditional breaks, skipping code that
  will not be executed in this path.

  Since the search only happens in between function calls, this
  heuristic is still linear in the number of nodes.
 
  It might leave holes in the register allocation, but the
  optimization problem is NP-hard, so we must stop somewhere.

- [(rw)constant-lift]: in RW mode, since loops are executed inside the same
  frame as the function, Const instructions that are executed repeatedly
  should be lifted to outside of the loops. It is theoretically possible
  for this optimization to worsen the performance, in case there are unlikely
  branches inside the loop with Const instructions that would otherwise
  never be executed. These should only a problem in very specific cases,
  but to work around that, we can only lift Consts that are unconditionally
  executed in the loop.

- [(rw)constant-deduplication]: unlike in WOM mode, constant deduplication
  should work across loop boundaries.
