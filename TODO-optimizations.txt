This files describes all the optimizations ideas we left out for now.

- [block_tree]: track whether a block is ever broken to (explicitly or
  implictly), so that we know if anything after it is dead code to be
  removed. Dead code removal translates to less data dependency in the
  DAG, which translates to possibly less data copies in the final code.
  But there shouldn't be any already, if the WASM is from an optimizing
  compiler.

- [locals_data_flow]: track locals permutation. If some locals are read into
  a block, but in the end they are just output unmodified (either on stack
  or on some local), this can be resolved statically when building the DAG,
  eliding copies.

- [locals_data_flow]: sometimes a loop needs to take locals as inputs
  just to output them in certain breaks, unmodified. Such locals would
  have to be copied over through all the iterations, but never actually
  used inside the loop. In such cases, it is worth to make these breaks
  indirect, by creating blocks surrounding the loop just to forward the
  breaks. The passthrough locals will be handled by the outside blocks
  and breaks, avoiding them to be copied into the loop.

- [register_allocation]: the register allocation is not perfectly optimal,
  it just uses a greedy approach to assign registers, and give up when it
  detects a conflict. It may be possible to model the problem to a SAT
  solver or something like that.

- if there are more than one loop nested inside each other, and the inner
  loop falls through the outer loop, which then breaks or falls through
  again, it is better to have the inner loop break directly to the final
  destination instead of going through multiple frame barriers, because
  each frame barrier potentially adds multiple copies.

- [tail call]: a call immediately followed by a return can be optimized
  to a tail call. We can even do this for calls where its outputs
  are not related to the return values, because we can set the
  return registers before the tail call.

- [liveness]: calculate the liveness for all possible control flow paths,
  releasing values earlier when possible, which may reduce register
  pressure.

- [rw-register-allocation]: implement a simple heuristic to try to avoid
  having to copy the function outputs to the slots allocated for them by
  the nodes who uses them as inputs.
  
  The idea goes like this: we first check if an output slot was specifically
  requested by the user node with a hint. If it was, then we most likely
  have to do copy it anyway, so we stop. If it wasn't, we check if between
  this call and the last user of the output there are no other function calls
  (and we must check inside the loop blocks as well). If there are not,
  then we can set the output slots to the ones that naturally
  follow from the function call, avoiding a register copy. In this
  case, it is also possible that we can shift the call frame
  itself some slots up, as the removal of the original output slots
  might have freed up some space.

  The search can follow uncoditional breaks, skipping code that
  will not be executed in this path.

  Since the search only happens in between function calls, this
  heuristic is still linear in the number of nodes.
 
  It might leave holes in the register allocation, but the
  optimization problem is NP-hard, so we must stop somewhere.
