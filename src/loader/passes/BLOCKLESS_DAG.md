# Blockless DAG Pass

**Source:** `blockless_dag.rs`

**Input:** `DanglingOptDag` (optimized DAG with nested blocks and loops)
**Output:** `BlocklessDag` (flat DAG with labels; only loops retain sub-DAGs)

## Purpose

This is the last common pipeline pass before the backend-specific stages. It
flattens the nested block structure into a linear sequence of nodes with labels
marking jump targets. After this pass, the only nesting that remains is for
loops — each loop still has its own sub-DAG, because loops represent a separate
"frame" with its own address space in the final output.

Non-loop blocks are fully inlined into their parent DAG, with their outputs
becoming labels that breaks can jump to. This makes the representation much
closer to assembly: a flat sequence of operations with forward-only jumps to
labels.

## Key Transformation

### Blocks Become Labels

A non-loop block in the input DAG:
```
Block {
    kind: Block,
    sub_dag: [Inputs, ..., Br(0, outputs)]
}
```

is inlined into the parent. The block's input node is suppressed (its outputs
are remapped to the corresponding inputs in the parent scope), and a `Label`
node is inserted where the block's outputs would be consumed. Break instructions
targeting the block become jumps to this label.

### Loops Remain Nested

Loop blocks keep their sub-DAG structure:
```
Loop {
    sub_dag: BlocklessDag { nodes: [...] },
    break_targets: [(depth, [target_types])]
}
```

The `break_targets` field records all the break targets that the loop body
uses, relative to the parent frame. This lets the backend know which external
labels/frames the loop may jump to.

## Break Target Resolution

In the input DAG, break targets are relative depths into the block stack. In the
blockless DAG, targets are resolved into `BreakTarget { depth, kind }`:

- **`depth`**: The number of frame levels between the break and the target. At
  the top level, depth 0 means the current function/loop frame. Inside a loop,
  depth 1 means the parent frame, depth 2 the grandparent, etc.

- **`kind`**: Either `FunctionOrLoop` (targeting the function return or a loop's
  next iteration) or `Label(id)` (targeting a specific label created from an
  inlined block).

The key property: **jumps to labels are always forward** (labels appear after
the jumps that target them), while **jumps to loops go backward** (to the loop
header at the start of the loop's sub-DAG).

## Example

Input DAG (with nested block):
```
Node 0: Inputs           → [x]
Node 1: Block {
    kind: Block,
    sub_dag: [
        Node 0: Inputs       → [x]
        Node 1: i32.const 10
        Node 2: i32.gt_s     ← [(0,0), (1,0)]
        Node 3: br_if 0      ← [(0,0), (2,0)]    ;; exit block if x > 10
        Node 4: i32.const 0
        Node 5: br 1         ← [(4,0)]            ;; return 0
    ]
}                         → [result]
Node 2: br 0             ← [(1,0)]                ;; return result
```

Output blockless DAG (flattened):
```
Node 0: Inputs           → [x]
Node 1: i32.const 10
Node 2: i32.gt_s         ← [(0,0), (1,0)]
Node 3: BrIf(Label(42))  ← [(0,0), (2,0)]        ;; jump to label if x > 10
Node 4: i32.const 0
Node 5: Br(Function)     ← [(4,0)]                ;; return 0
Node 6: Label { id: 42 } → [result]               ;; target for the br_if
Node 7: Br(Function)     ← [(6,0)]                ;; return result
```

The block's internal input node (its node 0) was suppressed and its references
were remapped to the parent's node 0. The block itself became a label node.

## Node Remapping

When blocks are inlined, node indices change. The pass maintains an
`outputs_map: HashMap<ValueOrigin, ValueOrigin>` that translates old
`(node, output)` pairs to new ones. For inlined block inputs, the map redirects
through the `input_mapping` to the actual source nodes in the parent.

## Design Notes

- Labels use unique IDs generated by a shared `AtomicU32` counter (the
  `LabelGenerator`), ensuring uniqueness across all functions and all frames.

- The pass preserves the `NodeInput::Constant` variant, passing inline
  constants through unchanged.

- Break targets are resolved relative to frame boundaries, not block nesting.
  This is important because the backends allocate registers per-frame (per
  function or per loop body), not per-block.
